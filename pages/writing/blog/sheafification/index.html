<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
  <link rel="stylesheet" href="/css/basic.css">
  <link rel="icon" href="/assets/cutebothead.jpg">
   <title>Thoughts on Sheafification</title>  
</head>
<body>
  <header>
  <nav>
    <a href="/">About</a>
    <a href="/pages/research/">Research</a>
    <a href="/pages/teaching/">Teaching</a>
    <a href="/pages/writing/">Journal</a>
    <a href="/pages/misc/">More Things to Click</a>
  </nav>
</header>


<!-- Content appended here -->
<div class="franklin-content">
<h1 id="thoughts_on_sheafification"><a href="#thoughts_on_sheafification" class="header-anchor">Thoughts on Sheafification</a></h1>
<p style='font-style: italic;text-align: center;'>by <a href='/'>Isaac</a> on 2023-09-13 </p>
<p>Sheafification felt opaque to me when I first learned it from Hartshorne, I&#39;ll admit. I reviewed it recently to recover from summer rustiness and wanted to make the argument that it is, in fact, actually pretty straightforward.</p>
<p>There are two additional axioms a presheaf \(\mathcal F\) on \(X\) must satisfy to be a sheaf:</p>
<ol>
<li><p>&#40;<em>Locality</em>&#41; &nbsp;Let \(U\) be covered by \(U_i\). If \(s,t \in \mathcal F(U)\) satisfy \(s|_{U_i} = t|_{U_i}\) for all \(i\), then \(s = t\).</p>
</li>
<li><p>&#40;<em>Gluing</em>&#41; &nbsp;&nbsp; Again let \(U\) be covered by \(U_i\). If there exist sections \(s_i \in \mathcal F(U_i)\) such that \(s_i|_{U_i\cap U_j} = s_j|_{U_i \cap U_j}\) then there exists some \(s \in \math cal F(U)\) such that \(s|_{U_i} = s_i\).</p>
</li>
</ol>
<p>Thus, there are two ways a sheaf can fail to be a presheaf: it can violate locality by having <em>extra</em> sections which are equal locally but not globally or it can violate gluing by having <em>too few</em> sections to glue stuff together. Sheafification therefore consists of removing all sections which violate locality and adding extra sections to ensure gluing is possible. There&#39;s an excellent mathoverflow post this: <a href="https://mathoverflow.net/questions/45212/how-should-one-think-about-sheafification-and-the-difference-between-a-sheaf-and">here&#39;s a link</a>. It also motivated this entry.</p>
<div class=" gradient"><span class="fancytext"> Examples</span></div>
<p>Examples of presheaves which violate gluing are pretty natural; lots of properties are easy or even trivial to satisfy locally but are much harder to satisfy globally.</p>
<div class="revindentparagraph"><span><strong> Example 1:</strong> <em> &#40;Violating Gluing&#41;</em>&nbsp;&nbsp;</span> Let \(X = S^1\), and pick two distinct points \(p \neq q \in S^1\). For any \(U\subseteq S^1\) define \(\mathcal F(U)\) to be all continuous functions \(f:U\to \mathbb R\) such that \(f(p) = f(q)\). Whenever \(U\) includes \(p\) but not \(q\), this equality condition disappears and \(\mathcal F(U)\) is the set of <em>all</em> continuous functions on \(U\). Therefore if \(U\) is a neighborhood of \(p\) which avoids \(q\) and \(V\) a neighborhood of \(q\) which avoids \(p\), then two sections \(f\in \mathcal F(U)\) and \(g\in \mathcal F(V)\) only glue if they agree on \(U\cap V\) and if \(f(p) = g(q)\). Sheafification of \(\mathcal F\) adds in all these extra sections, and thus the sheafification of \(\mathcal F\) is the sheaf of continuous functions on \(S^1\).</div>
<p><em>Takeaway: The property \(f(p) = f(q)\) is not a local property, hence it is removed.</em></p>
<div class="revindentparagraph"><span><strong> Example 2:</strong> <em> &#40;Violating Gluing&#41;</em>&nbsp;&nbsp;</span> Let \(X = \mathbb C\) and define \(\mathcal F(U)\) to be the collection of all polynomials bounded on \(U\). If we additionally define \(\mathcal F(\emptyset) = 0\) &#40;see the Appendix&#41; then \(\mathcal F\) is a presheaf. As long as \(U\) itself is bounded and nonempty, \(\mathcal F(U) = \mathbb C[z]\), but Louiville&#39;s theorem tells us that the only bounded holomorphic functions on all of \(\mathbb C\) are constant. In particular, if \(D_r\) is the open disk of radius \(r\) centered at \(0\), then \(f(z) = z\) is bounded on \(D_r\), but there is no section \(g \in \mathcal F(\mathbb C) = \mathbb C\) such that \(g|_{D_r}(z) = f(z)\). Sheafification applied to \(\mathcal F\) therefore adds in the extra functions; it just expands \(\mathcal F(U)\) so that it too is \(\mathbb C[z]\). The sheafification of \(\mathcal F\) is therefore the constant sheaf associated to \(\mathbb C[z]\).</div>
<p><em>Takeaway: A function can be simultaneously be bounded locally and unbounded globally. Hence the &#39;bounded&#39; condition is removed.</em></p>
<p>Examples of locality violation feel less natural to me because it&#39;s hard to construct them by imposing conditions on sets of functions. After all, if two functions are equal in every neighborhood of a space, then they&#39;re equal everywhere. It feels better to think about &quot;equivalence&quot;, in my opinion. I can easily imagine two things which are &quot;similar locally&quot; but are not similar globally. Here&#39;s an example utilizing the boundedness example from earlier.</p>
<div class="revindentblock"><p><span><strong> Example 3:</strong> <em> &#40;Violating Locality&#41;</em>&nbsp;&nbsp;</span> Again let \(X = \mathbb C\), let \(\mathcal F\) be the sheaf of holomorphic functions and let \(\mathbb G\) be the presheaf of bounded holomorphic functions. Now define a presheaf \(\mathcal H(U) = \mathcal F(U)/\mathcal G(U)\). At any \(x\in X\) we get \(\mathcal H_x = 0\), since any holomorphic function defined at \(x\) is bounded in a suitably small neighborhood of \(x\). However, functions like \(f(z) = z\) are not in the class of zero in \(\mathcal H(X)\), since they are not bounded globally. Contrast these two sets:</p>
<ul>
<li><p>\(\mathcal H_x = \{0\}\) for reasons described above</p>
</li>
<li><p>\(\mathcal H(X) = \{\text{entire functions}\}/\mathbb C\), since the only bounded functions on \(X\) are the constant functions.</p>
</li>
</ul>
<p>The set \(\mathcal H(U)\) is kind of like &quot;unbounded functions on \(U\) up to boundedness&quot;. Two functions \(f\) and \(g\) can both be bounded on a small set \(U\), but for a strictly larger set \(f\) might become unbounded while \(g\) remains bounded. The sheafification of \(\mathcal H\) throws away all sections for which local equivalence doesn&#39;t imply global equivalence. Since all holomorphic functions are equivalent to a bounded function on a sufficiently small set, this is just the constant zero sheaf.</p>
<p><em>Takeaway: Locally bounded doesn&#39;t imply globally bounded for all sections, so all sections which are only locally bounded are thrown out.</em></p></div>
<p>Now let&#39;s look at some more general examples that show up immediately after you define sheafification. These sheafification examples are imperative to understand, since we use the sections of these sheaves <em>all the time</em>. If you fall back on the universal property of sheafification in these cases to avoid thinking about sections, then you&#39;re robbing yourself of valuable intuition and insight. <div class=" gradient"><span class="fancytext"> Kernel, Image and Cokernel Shaves</span></div> Say we have a map \(\varphi:\mathcal F\to \mathcal G\) of sheaves on a topological space \(X\). We can immediately define kernel, image and cokernel presheaves on \(X\):</p>
<ul>
<li><p>\(\operatorname{ker}^p \varphi (U) = \operatorname{ker}(\varphi(U): \mathcal F(U)\to \mathcal G(U))\subseteq \mathcal F(U)\)</p>
</li>
<li><p>\(\operatorname{im}^p \varphi (U) = \operatorname{im}(\varphi(U): \mathcal F(U)\to \mathcal G(U))\subseteq \mathcal G(U)\)</p>
</li>
<li><p>\(\operatorname{coker}^p \varphi(U) = \operatorname{coker}(\varphi(U): \mathcal F(U)\to \mathcal G(U))\)</p>
</li>
</ul>
<p>These are presheaves, but are they sheaves? Fix \(U\subseteq X\) and a cover \(\{U_i\}\) of \(U\).</p>
<h4 id="the_kernel_presheaf_is_a_sheaf"><a href="#the_kernel_presheaf_is_a_sheaf" class="header-anchor">The kernel presheaf is a sheaf</a></h4>
<div class="revindentparagraph"><em>Locality:</em> Everything is happening in \(\mathcal F(U)\), so this is easy. Given a section \(s\in \operatorname{ker}^p\varphi(U)\) whose restriction \(s|_{U_i} = 0\) is zero for all \(i\), we automatically have that \(s = 0\) on \(U\) since \(s|_{U_i} \in \mathcal F(U_i)\), \(s\in \mathcal F(U)\) and \(\mathcal F\) is a sheaf.</div>
<div class="revindentblock"><p><em>Gluing:</em> Given \(s_i \in \mathcal \operatorname{ker}^p\varphi(U_i)\) so that \(s_i|_{U_i\cap U_j} = s_j|_{U_i\cap U_j}\), we want to find a section \(s\in \operatorname{ker}^p\varphi(U)\) whose restriction to \(U_i\) recovers \(s_i\). Such a section certainly exists in \(\mathcal F(U)\) because \(\mathcal F\) is a sheaf, but is this in the kernel of \(\varphi\)? Yes, it is â€“ we need to move over to \(\mathcal G\) to see it. The map \(\varphi\) commutes with restrictions, so </p>
\[\varphi(s)|_{U_i} = \varphi(s|_{U_i}) = \varphi(s_i) = 0\]
<p>in \(\mathcal G(U_i)\) by the assumption that \(s_i\in \operatorname{ker}^p\varphi(U_i) = \operatorname{ker}(\varphi(U_i))\). But \(\mathcal G\) is also a sheaf, hence satisfies locality and thus \(\varphi(s) = 0\) in \(\mathcal G(U)\). This implies \(s\in \operatorname{ker}^p\varphi(U)\).</p></div>
<p>Therefore \(\operatorname{ker}^p\varphi\) is indeed a sheaf, so we remove the \(p\) and define \(\operatorname{ker}\varphi := \operatorname{ker}^p\varphi\).</p>
<h4 id="the_image_presheaf_fails_gluing"><a href="#the_image_presheaf_fails_gluing" class="header-anchor">The image presheaf fails gluing</a></h4>
<p>We&#39;re not so lucky in the case of the image presheaf. It <em>does</em> satisfy locality:</p>
<div class="revindentparagraph"><em>Locality:</em> Take \(s\in \operatorname{im}^p\varphi(U)\) whose restriction to each \(U_i\) is zero. By virtue of being a section of \(\mathcal G(U)\), this immediately implies \(s = 0\) because \(\mathcal G\) is a sheaf.</div>
<p>But notice what goes wrong when we try to glue:</p>
<div class="revindentparagraph"><em>Gluing:</em> Given a collection of \(s_i \in \operatorname{im}^p\varphi(U_i)\) which agree on overlaps, we want a section \(s \in\operatorname{im}^p\varphi(U)\) which restricts to \(s_i\) at each \(U_i\). Again, because \(\mathcal G\) is a sheaf, there is a unique section of \(\mathcal G(U)\) which satisfies this. However, unless \(\varphi(U)\) is surjective, we can&#39;t guarantee that this \(s\) is in \(\operatorname{im}^p\varphi(U)\). Thus \(\operatorname{im}^p\varphi\) isn&#39;t a sheaf <em>unless</em> \(\varphi(U)\) is surjective for each \(U\).</div>
<p>A sheaf which satisfies locality but not gluing is called a <strong>separated presheaf</strong>. To obtain an image sheaf, we simply sheafify: \(\operatorname{im}\varphi := (\operatorname{im}^p\varphi)^\sim\).</p>
<p>All we&#39;ve done is add the missing sections from \(\mathcal G(U)\) into \(\operatorname{im}^p\varphi(U)\), so \(\operatorname{im}\varphi\) is most definitely still a subsheaf of \(\mathcal G\).</p>
<h4 id="the_cokernel_presheaf_fails_locality"><a href="#the_cokernel_presheaf_fails_locality" class="header-anchor">The cokernel presheaf fails locality</a></h4>
<p>If we look back at the bounded holomorphic sections examples, you&#39;ll notice that the failure of locality in Example 3 was actually due to the failure of gluing in Example 2. This is a more general fact; if we take the quotient of a presheaf &#40;or sheaf&#41; by a presheaf which doesn&#39;t have the gluing property, then the resulting quotient presheaf won&#39;t have the locality property. To see what I mean, let&#39;s look at why locality fails for the cokernel presheaf:</p>
<div class="revindentparagraph"><em>Locality:</em> Same setup as always, we&#39;ve got a \(s\in \operatorname{coker}^p\varphi(U) = \mathcal G(U)/\operatorname{im}(\varphi(U))\) whose restrictions are all zero. This means \(s|_{U_i}\) is contained in \(\operatorname{im}(\varphi(U_i))\), but if we wish to conclude \(s = 0\) too, we&#39;d need \(s \in \operatorname{im}(\varphi(U))\). This doesn&#39;t happen in general, exactly because the image presheaf doesn&#39;t glue&#33;</div>
<p>The cokernel doesn&#39;t actually satisfy gluing either.</p>
<div class="revindentblock"><em>Gluing:</em> Standard setup by now: \(s_i \in \operatorname{coker}^p\varphi(U_i)\) are sections which agree on intersections \(U_i\cap U_j\). Each \(s_i\) is represented by some</div>
<h2></h2>
<div class="page-foot">
  Â©Isaac Martin. Last modified: November 20, 2023.
</div>
</div><!-- CONTENT ENDS HERE -->
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
